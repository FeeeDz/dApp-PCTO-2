import { TYPE_AMOUNT, Web3SideChainClient, ITransactionOption, IApproveTransactionOption, IAllowanceTransactionOption } from "@maticnetwork/maticjs";
import { IPlasmaClientConfig, IPlasmaContracts } from "./interfaces";
import { PlasmaToken } from "./plasma_token";
export declare class ERC20 extends PlasmaToken {
    constructor(tokenAddress: string, isParent: boolean, client: Web3SideChainClient<IPlasmaClientConfig>, contracts: () => IPlasmaContracts);
    getPredicate(): Promise<import("@maticnetwork/maticjs").BaseContract>;
    getBalance(userAddress: string, option?: ITransactionOption): Promise<string>;
    /**
     * get allowance for user
     *
     * @param {string} userAddress
     * @param {ITransactionOption} [option]
     * @returns
     * @memberof ERC20
     */
    getAllowance(userAddress: string, option?: IAllowanceTransactionOption): Promise<string>;
    approve(amount: TYPE_AMOUNT, option?: IApproveTransactionOption): Promise<import("@maticnetwork/maticjs").ITransactionWriteResult>;
    approveMax(option?: ITransactionOption): Promise<import("@maticnetwork/maticjs").ITransactionWriteResult>;
    deposit(amount: TYPE_AMOUNT, userAddress: string, option?: ITransactionOption): Promise<import("@maticnetwork/maticjs").ITransactionWriteResult>;
    private depositEther_;
    withdrawStart(amount: TYPE_AMOUNT, option?: ITransactionOption): Promise<import("@maticnetwork/maticjs").ITransactionWriteResult>;
    private withdrawConfirm_;
    withdrawConfirm(burnTxHash: string, option?: ITransactionOption): Promise<import("@maticnetwork/maticjs").ITransactionWriteResult>;
    withdrawConfirmFaster(burnTxHash: string, option?: ITransactionOption): Promise<import("@maticnetwork/maticjs").ITransactionWriteResult>;
    transfer(amount: TYPE_AMOUNT, to: string, option?: ITransactionOption): Promise<import("@maticnetwork/maticjs").ITransactionWriteResult>;
}
